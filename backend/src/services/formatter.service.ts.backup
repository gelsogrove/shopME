/**
 * Formatter Service
 *
 * Centralizes all response formatting rules for ShopME chatbot.
 * Handles cart display, product formatting, and system response styling.
 * Supports multiple languages: IT, EN, ES, PT
 *
 * üé≠ PERSONALIT√Ä E STILE:
 * - Tono: Professionale ma caldo e accogliente, tipicamente italiano
 * - Multilingua: Adatta automaticamente la lingua all'utente
 * - Proattivo: Suggerisce prodotti correlati e ricette abbinate
 * - Esperto: Condivide conoscenze sui prodotti italiani e la loro origine
 *
 * üìã BEST PRACTICES:
 * 1. Sempre contestualizza le risposte con le informazioni dell'utente
 * 2. Suggerisce abbinamenti quando possibile (ricette + prodotti)
 * 3. √à specifico sui dettagli dei prodotti (origine, caratteristiche)
 * 4. Offre alternative se un prodotto non √® disponibile
 * 5. Facilita il contatto con l'operatore quando necessario
 */

export class FormatterService {
  // Simple in-memory cache for translated category names: key -> workspaceId:language:categoryId
  private static categoryTranslationCache: Map<string, string> = new Map()
  private static async replaceAllVariables(
    response: string,
    customerId?: string,
    workspaceId?: string,
    language?: string,
    customerDiscount?: number
  ): Promise<string> {
    console.log(
      "üîß Formatter: replaceAllVariables called with:",
      response.substring(0, 100)
    )

    // üö® EXCEPTION HANDLING: Parameter validation
    if (!workspaceId) {
      throw new Error("workspaceId is required for variable replacement")
    }

    // Handle [LIST_CATEGORIES] VARIABLE
    if (response.includes("[LIST_CATEGORIES]")) {
      console.log("üîß Formatter: Found [LIST_CATEGORIES] VARIABLE!")

      try {
        // ‚úÖ USE EXISTING SERVICE: CategoryService
        const {
          CategoryService,
        } = require("../application/services/category.service")
        const categoryService = new CategoryService()

        const categories = await categoryService.getAllForWorkspace(workspaceId)
        if (categories && categories.length > 0) {
          // Translate category names to customer's language if provided
          const translationService =
            new (require("./translation.service").TranslationService)()

          const translatedNames = await Promise.all(
            categories.map(async (category) => {
              const cacheKey = `${workspaceId}:${language || "it"}:${category.id}`
              if (this.categoryTranslationCache.has(cacheKey)) {
                return {
                  id: category.id,
                  name: this.categoryTranslationCache.get(cacheKey)!,
                }
              }

              try {
                const translated = await translationService.translateToLanguage(
                  category.name,
                  language || "it"
                )
                // store in cache
                this.categoryTranslationCache.set(cacheKey, translated)
                return { id: category.id, name: translated }
              } catch (e) {
                // If translation fails, fall back to original name
                return { id: category.id, name: category.name }
              }
            })
          )

          const categoriesList = categories
            .map((category) => {
              const translated =
                translatedNames.find((t: any) => t.id === category.id)?.name ||
                category.name
              const emoji = this.getCategoryEmoji(translated)
              return `- ${emoji} *${translated}*`
            })
            .join("\n")

          response = response.replace("[LIST_CATEGORIES]", categoriesList)
        }
      } catch (error) {
        // üö® EXCEPTION HANDLING: Database query failure
        throw new Error(
          `Database query failed for [LIST_CATEGORIES]: ${error.message}`
        )
      }
    }

    // Handle [USER_DISCOUNT] VARIABLE
    if (response.includes("[USER_DISCOUNT]")) {
      console.log("üîß Formatter: Found [USER_DISCOUNT] VARIABLE!")

      // üö® EXCEPTION HANDLING: Parameter validation
      if (!customerId) {
        throw new Error(
          "customerId is required for [USER_DISCOUNT] variable replacement"
        )
      }

      try {
        // ‚úÖ USE EXISTING SERVICE: PriceCalculationService
        const {
          PriceCalculationService,
        } = require("../application/services/price-calculation.service")
        const { PrismaClient } = require("@prisma/client")
        const prisma = new PrismaClient()
        const priceService = new PriceCalculationService(prisma)

        const discounts = await priceService.getAvailableDiscounts(
          workspaceId,
          customerId
        )

        await prisma.$disconnect()

        if (discounts.customerDiscount > 0) {
          response = response.replace(
            "[USER_DISCOUNT]",
            `${discounts.customerDiscount}%`
          )
        } else {
          // üö® GRACEFUL HANDLING: No discount
          response = response.replace(
            "[USER_DISCOUNT]",
            "Nessuno sconto attivo al momento üôè"
          )
        }
      } catch (error) {
        // üö® EXCEPTION HANDLING: Database query failure
        throw new Error(
          `Database query failed for [USER_DISCOUNT]: ${error.message}`
        )
      }
    }

    // Handle [LINK_ORDERS_WITH_TOKEN] VARIABLE
    if (response.includes("[LINK_ORDERS_WITH_TOKEN]")) {
      console.log("üîß Formatter: Found [LINK_ORDERS_WITH_TOKEN] VARIABLE!")

      // üö® EXCEPTION HANDLING: Parameter validation
      if (!customerId) {
        throw new Error(
          "customerId is required for [LINK_ORDERS_WITH_TOKEN] variable replacement"
        )
      }

      try {
        // ‚úÖ USE EXISTING SERVICE: SecureTokenService
        const {
          SecureTokenService,
        } = require("../application/services/secure-token.service")
        const secureTokenService = new SecureTokenService()

        const ordersToken = await secureTokenService.createToken(
          "orders",
          workspaceId,
          { customerId, workspaceId },
          "1h",
          undefined,
          undefined,
          undefined,
          customerId
        )

        const ordersLink = `http://localhost:3000/orders-public?token=${ordersToken}`
        response = response.replace("[LINK_ORDERS_WITH_TOKEN]", ordersLink)
      } catch (error) {
        // üö® EXCEPTION HANDLING: Token generation failure
        throw new Error(
          `Token generation failed for [LINK_ORDERS_WITH_TOKEN]: ${error.message}`
        )
      }
    }

    // Handle other tokens using existing ReplaceLinkWithToken function
    const hasListAllProducts = response.includes("[LIST_ALL_PRODUCTS]")
    const hasListServices = response.includes("[LIST_SERVICES]")
    const hasListOffers = response.includes("[LIST_OFFERS]")
    const hasListActiveOffers = response.includes("[LIST_ACTIVE_OFFERS]")
    const hasLinkProfile = response.includes("[LINK_PROFILE_WITH_TOKEN]")
    const hasLinkCart = response.includes("[LINK_CART_WITH_TOKEN]")
    const hasLinkTracking = response.includes("[LINK_TRACKING_WITH_TOKEN]")
    const hasLinkCheckout = response.includes("[LINK_CHECKOUT_WITH_TOKEN]")
    const hasLinkLastOrderInvoice = response.includes(
      "[LINK_LAST_ORDER_INVOICE_WITH_TOKEN]"
    )

    console.log("üîß Formatter: Token detection:", {
      hasListAllProducts,
      hasListServices,
      hasListOffers,
      hasListActiveOffers,
      hasLinkProfile,
      hasLinkCart,
      hasLinkTracking,
      hasLinkCheckout,
      hasLinkLastOrderInvoice,
      response: response.substring(0, 100),
    })

    // Handle [LIST_ALL_PRODUCTS] token with GetAllProducts function
    if (hasListAllProducts) {
      console.log(
        "üîß Formatter: Found [LIST_ALL_PRODUCTS] token, calling GetAllProducts"
      )

      try {
        const {
          GetAllProducts,
        } = require("../chatbot/calling-functions/GetAllProducts")

        if (!customerId || !workspaceId) {
          throw new Error(
            "customerId and workspaceId are required for GetAllProducts"
          )
        }

        const productsResult = await GetAllProducts({
          phoneNumber: "unknown", // We don't have phone number in formatter context
          workspaceId: workspaceId,
          customerId: customerId,
          message: "Get all products",
          language: language || "it",
        })

        console.log("üîß Formatter: GetAllProducts returned:", {
          success: !!productsResult.response,
          totalProducts: productsResult.totalProducts,
        })

        if (productsResult.response) {
          // Replace [LIST_ALL_PRODUCTS] with the raw response from GetAllProducts
          response = response.replace(/\[LIST_ALL_PRODUCTS\]/g, productsResult.response)
          console.log("üîß Formatter: Replaced [LIST_ALL_PRODUCTS] with raw products response")
        }
      } catch (error) {
        console.error("‚ùå Formatter: GetAllProducts error:", error)
        // Replace with fallback message
        response = response.replace(
          /\[LIST_ALL_PRODUCTS\]/g,
          language === "it"
            ? "Nessun prodotto disponibile al momento"
            : "No products available at the moment"
        )
      }
    }

    // Handle other tokens using existing ReplaceLinkWithToken function
    if (
      hasListOffers ||
      hasListActiveOffers ||
      hasListServices ||
      hasLinkProfile ||
      hasLinkCart ||
      hasLinkTracking ||
      hasLinkCheckout ||
      hasLinkLastOrderInvoice
    ) {
      console.log("üîß Formatter: Found tokens that need replacement:", {
        hasListAllProducts: response.includes("[LIST_ALL_PRODUCTS]"),
        hasListServices: response.includes("[LIST_SERVICES]"),
        hasListOffers: response.includes("[LIST_OFFERS]"),
        customerId: customerId,
        workspaceId: workspaceId,
      })

      try {
        const {
          ReplaceLinkWithToken,
        } = require("../chatbot/calling-functions/ReplaceLinkWithToken")

        console.log("üîß Formatter: Token replacement params:", {
          customerId: customerId,
          workspaceId: workspaceId,
          hasCustomerId: !!customerId,
          hasWorkspaceId: !!workspaceId,
        })

        if (!customerId || !workspaceId) {
          throw new Error(
            "customerId and workspaceId are required for token replacement"
          )
        }

        console.log("üîß Formatter: About to call ReplaceLinkWithToken with:", {
          response: response.substring(0, 100),
          customerId,
          workspaceId,
        })

        // If the response string is actually JSON coming from a CF and contains
        // an orderCode, pass it through so ReplaceLinkWithToken can build a
        // URL with the order code in the path: /orders-public/{orderCode}?token=...
        let detectedOrderCode: string | undefined = undefined
        try {
          const parsedResp = JSON.parse(response)
          if (parsedResp && parsedResp.orderCode) {
            detectedOrderCode = parsedResp.orderCode
          }
        } catch (e) {
          // Not JSON, ignore
        }

        const replaceResult = await ReplaceLinkWithToken(
          { response, orderCode: detectedOrderCode },
          customerId,
          workspaceId
        )

        console.log("üîß Formatter: ReplaceLinkWithToken returned:", {
          success: replaceResult.success,
          hasResponse: !!replaceResult.response,
          error: replaceResult.error,
        })

        console.log("üîß Formatter: ReplaceLinkWithToken result:", {
          success: replaceResult.success,
          hasResponse: !!replaceResult.response,
          error: replaceResult.error,
        })

        if (replaceResult.success && replaceResult.response) {
          response = replaceResult.response
          console.log(
            "üîß Formatter: Response after replacement:",
            response.substring(0, 200)
          )
        }
      } catch (error) {
        console.error("‚ùå Formatter: Error replacing other tokens:", error)
      }
    }

    return response
  }

  private static getCategoryEmoji(categoryName: string): string {
    const lowerCategory = categoryName.toLowerCase()

    if (
      lowerCategory.includes("cheese") ||
      lowerCategory.includes("dairy") ||
      lowerCategory.includes("formaggi") ||
      lowerCategory.includes("latticini")
    ) {
      return "üßÄ"
    } else if (
      lowerCategory.includes("frozen") ||
      lowerCategory.includes("surgelati") ||
      lowerCategory.includes("gelati")
    ) {
      return "üßä"
    } else if (
      lowerCategory.includes("sauce") ||
      lowerCategory.includes("salsa") ||
      lowerCategory.includes("preserve") ||
      lowerCategory.includes("conserve")
    ) {
      return "üçÖ"
    } else if (
      lowerCategory.includes("spice") ||
      lowerCategory.includes("spezie") ||
      lowerCategory.includes("herb") ||
      lowerCategory.includes("erbe")
    ) {
      return "üåø"
    } else if (
      lowerCategory.includes("pasta") ||
      lowerCategory.includes("rice")
    ) {
      return "üçù"
    } else if (
      lowerCategory.includes("meat") ||
      lowerCategory.includes("salumi") ||
      lowerCategory.includes("salami")
    ) {
      return "üçñ"
    } else if (
      lowerCategory.includes("water") ||
      lowerCategory.includes("beverage") ||
      lowerCategory.includes("bevanda")
    ) {
      return "üíß"
    } else if (
      lowerCategory.includes("flour") ||
      lowerCategory.includes("baking") ||
      lowerCategory.includes("farina")
    ) {
      return "üåæ"
    } else if (
      lowerCategory.includes("tomato") ||
      lowerCategory.includes("pomodoro")
    ) {
      return "üçÖ"
    } else {
      return "üì¶" // Default emoji
    }
  }
  static async formatResponse(
    response: string,
    language: string = "it",
    formatRules?: string,
    customerId?: string,
    workspaceId?: string,
    originalQuestion?: string,
    customerDiscount?: number,
    conversationHistory?: Array<{ role: string; content: string }>
  ): Promise<string> {
    console.log("üîß FORMATTER: ===== START FORMATTING =====")
    console.log("üîß FORMATTER: Input response:", response)
    console.log("üîß FORMATTER: Language:", language)
    console.log("üîß FORMATTER: Customer ID:", customerId)
    console.log("üîß FORMATTER: Workspace ID:", workspaceId)

    if (!response || response.trim() === "") {
      return language === "it" ? "Nessuna risposta disponibile." : "No response available."
    }

    // FLUSSO PULITO FORMATTER - SOLO TRADUZIONE NATURALE
    let formattedResponse = response

    // 1. Sostituisci i token prima
    try {
      formattedResponse = await this.replaceAllVariables(
        response,
        customerId,
        workspaceId,
        language,
        customerDiscount
      )
      console.log("‚úÖ FORMATTER: Token replacement completed")
      console.log("üîß FORMATTER: After token replacement:", formattedResponse)
    } catch (error) {
      console.error("‚ùå FORMATTER: Token replacement error:", error.message)
      formattedResponse = response
    }

    // 2. Return content as-is - no intermediate formatting
    let finalResponse = await this.applySimpleLanguageFormatting(
      formattedResponse,
      language,
      originalQuestion
    )
    
    console.log("üîß FORMATTER: Final response:", finalResponse.substring(0, 200))

    return finalResponse
  }

  private static async applySimpleLanguageFormatting(
    text: string,
    language: string,
    originalQuestion: string
  ): Promise<string> {
    if (!text) return text

    console.log("üîß SIMPLE FORMATTER: Input:", {
      text: text.substring(0, 100),
      language,
      originalQuestion,
    })

    // For JSON responses, return the content as-is without any processing
    try {
      const parsed = JSON.parse(text)
      if (parsed && parsed.results && parsed.results.faqs && parsed.results.faqs.length > 0) {
        const faq = parsed.results.faqs[0]
        let content = faq.content || ""

        // Remove "Question: ..." and "Answer: " prefixes if present
        content = content
          .replace(/^Question:\s*.*?\nAnswer:\s*/i, "")
          .replace(/^Answer:\s*/i, "")
          .trim()

        // Return content as-is, let the FE handle the formatting
        return content
      }

      // For other JSON structures, return as-is
      return text
    } catch (e) {
      // Not JSON, return as-is
    }

    // For non-JSON text, return as-is (preserve markup)
    return text
  }
}
  ): Promise<string> {
    console.log("üîß FORMATTER: ===== START FORMATTING =====")
    console.log("üîß FORMATTER: Input response:", response)
    console.log("üîß FORMATTER: Language:", language)
    console.log("üîß FORMATTER: Format rules:", formatRules)
    console.log("üîß FORMATTER: Customer ID:", customerId)
    console.log("üîß FORMATTER: Workspace ID:", workspaceId)

    // Write to file for debugging
    const fs = require("fs")
    fs.appendFileSync(
      "/tmp/formatter-debug.log",
      `\n===== FORMATTER DEBUG =====\n`
    )
    fs.appendFileSync("/tmp/formatter-debug.log", `Input: ${response}\n`)
    fs.appendFileSync("/tmp/formatter-debug.log", `Language: ${language}\n`)
    // If the incoming response is JSON and contains results.products, dump it separately for inspection
    try {
      const parsed = JSON.parse(response)
      if (
        parsed &&
        parsed.results &&
        Array.isArray(parsed.results.products) &&
        parsed.results.products.length > 0
      ) {
        const dumpPath = "/tmp/formatter-products-debug.log"
        fs.appendFileSync(
          dumpPath,
          `\n===== PRODUCTS DUMP ${new Date().toISOString()} =====\n`
        )
        fs.appendFileSync(
          dumpPath,
          JSON.stringify(parsed.results.products, null, 2) + "\n"
        )
        console.log(
          `üîß FORMATTER: Detected results.products, dumped ${parsed.results.products.length} products to ${dumpPath}`
        )
        fs.appendFileSync(
          "/tmp/formatter-debug.log",
          `Detected results.products and dumped to ${dumpPath}\n`
        )
      }
    } catch (e) {
      // Not JSON - ignore
    }
    if (!response || response.trim() === "") {
      return "Nessuna risposta disponibile."
    }

    // üö® CRITICAL RULE: NEVER INVENT ANYTHING - ONLY USE REAL DATABASE DATA
    const criticalRule = `
    üö® CRITICAL FORMATTING RULE - NEVER INVENT ANYTHING:
    - You are a helpful assistant for L'Altra Italia, specialized in Italian products
    - NEVER invent codes, dates, prices, products, links, or any information not in the database
    - NEVER add fake checkout codes, expiration dates, promotional messages, or website links
    - NEVER invent product names, discounts, offers, or any content
    - ONLY use the exact data provided in the response
    - If data is missing, say "Information not available" - DO NOT INVENT
    - NO FANTASY, NO CREATIVITY - ONLY REAL DATABASE FACTS
    - üö® ABSOLUTE RULE: If you don't have real data, don't make it up - just format what's there
    - üö® LINK RULE: NEVER add any links unless they are explicitly provided in the response
    - üö® NO WEBSITE LINKS: Do not add "Trova i nostri prodotti qui:" or any website links
    - üö® NO EXAMPLE LINKS: Do not use example.com, laltraitalia.com, or any other website links
    - ‚úÖ TOKEN RULE: Tokens have already been replaced with real data from the database
    - üö® FORBIDDEN: Adding "Trova i nostri prodotti qui:" or any website links
    - NON MOSTRARE MAI LO STOCK NON MOSTRARE MAI IL CODICE PRODOTTO
    - SE ARRIVANO LISTE DI DATO METTI I BULLETPOINT E ORGANIZZA PER categorie e tutti devono avere gli stessi spazi deve essere ben formattato.
    `

    // Combine critical rule with any additional format rules
    const combinedRules =
      criticalRule +
      (formatRules ? `\n\nADDITIONAL RULES:\n${formatRules}` : "")

    // FLUSSO PULITO FORMATTER - SOLO TRADUZIONE NATURALE
    let formattedResponse = response

    // 1. Sostituisci i token prima
    try {
      formattedResponse = await this.replaceAllVariables(
        response,
        customerId,
        workspaceId,
        language,
        customerDiscount
      )
      console.log("‚úÖ FORMATTER: Token replacement completed")
      console.log("üîß FORMATTER: After token replacement:", formattedResponse)
      fs.appendFileSync(
        "/tmp/formatter-debug.log",
        `After token replacement: ${formattedResponse}\n`
      )
    } catch (error) {
      console.error("‚ùå FORMATTER: Token replacement error:", error.message)
      formattedResponse = response
    }

    // 2. SOLO traduzione naturale - NESSUNA CONDIZIONE
    console.log("üîß FORMATTER: Applying simple natural language formatting...")
    // NOTE: Per le regole architetturali, NON effettuare pre-formatting o
    // logica di estrazione qui. Il Formatter deve solo formattare il testo
    // fornito e rispettare la lingua dell'utente. Se il payload contiene
    // JSON con `results.products` o `products`, l'LLM deve includerli
    // esattamente come appaiono nel testo. Le istruzioni per questo sono
    // fornite nel prompt di applySimpleLanguageFormatting.

    // Always use the simple language formatting LLM to produce the final
    // human-readable response. This centralizes natural-language generation in
    // one place (the Formatter) and avoids duplicating presentation logic here.
    // It also guarantees we follow the CRITICAL RULE: do not invent data.
    let finalResponse = await this.applySimpleLanguageFormatting(
      formattedResponse,
      language,
      originalQuestion
    )
    console.log(
      "üîß FORMATTER: Final response:",
      finalResponse.substring(0, 200)
    )
    fs.appendFileSync(
      "/tmp/formatter-debug.log",
      `Final result: ${finalResponse}\n`
    )
    fs.appendFileSync(
      "/tmp/formatter-debug.log",
      `===== END FORMATTER DEBUG =====\n`
    )

    return finalResponse
  }

  private static async applySimpleLanguageFormatting(
    text: string,
    language: string,
    originalQuestion: string
  ): Promise<string> {
    if (!text) return text

    console.log("üîß SIMPLE FORMATTER: Input:", {
      text: text.substring(0, 100),
      language,
      originalQuestion,
    })

    const prompt = `Tu sei un assistente per un negozio di prodotti italiani.

  DOMANDA UTENTE: ${originalQuestion}
  RISPOSTA DA FORMATTARE: ${text}
  LINGUA UTENTE: ${language}

  ISTRUZIONI RIGUARDO ALLE LISTE (versione MARKDOWN):
  - Se l'input √® un JSON che contiene un campo "results.products" o "products", procedi cos√¨:
    1) Raggruppa i prodotti per categoria (usa il campo category o "N/A" se assente).
    2) Per ogni categoria valida (non vuota), stampa un'intestazione di categoria con il formato: ## Nome Categoria
    3) Sotto l'intestazione, elenca ogni prodotto in UNA SOLA RIGA come bullet point con questo esatto formato Markdown:
       - **Nome prodotto** ‚Äî Formato ‚Äî Prezzo: ‚Ç¨X.XX
       Esempio: - **Mozzarella FDL Barra** ‚Äî 1 Kg ‚Äî Prezzo: ‚Ç¨7.20
    4) Omessi campi sensibili: NON mostrare lo stock, NON mostrare codici prodotto o SKU.
    5) Se un prodotto ha pi√π line-break o campi multilinea, normalizzali in una singola riga separando i campi con ' ‚Äî '.

  REGOLE GENERALI:
  
  - Mantieni esattamente i dati forniti (prezzi, nomi, formati). Non inventare nulla.
  - Per campi mancanti, usa "N/A".
  - Non aggiungere link, codici, date o informazioni non presenti nella sorgente.

  OUTPUT MARKDOWN:
  - Usa esattamente un trattino seguito da uno spazio per i bullet points: "- "
  - Usa **doppi asterischi** per il bold del nome (Markdown standard).
  - Usa ## per le intestazioni delle categorie.
  - Usa una linea vuota tra categorie diverse per separazione.
  - Formatta link con sintassi Markdown: [testo](url)
  - Usa *corsivo* per enfasi quando necessario.

  - Rispondi in modo naturale nella lingua dell'utente: (${language}). (se it e' italiano se e' en inglese se es e' spagnolo se pt e' portoghese) 
  Usa SEMPRE la formattazione Markdown standard. Se ci sono liste, usa bullet points Markdown. Organizza per categorie con intestazioni ##. Se viene fornito un link di checkout, NON chiedere all'utente di scrivere "nuovo ordine" - il link √® sufficiente per procedere.`

    try {
      const openRouterUrl = "https://openrouter.ai/api/v1/chat/completions"
      const response = await fetch(openRouterUrl, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${process.env.OPENROUTER_API_KEY}`,
          "Content-Type": "application/json",
          "HTTP-Referer": "http://localhost:3001",
          "X-Title": "ShopME Formatter",
        },
        body: JSON.stringify({
          model: "anthropic/claude-3.5-sonnet",
          messages: [{ role: "user", content: prompt }],
          temperature: 0.0,
        }),
      })

      if (!response.ok) {
        console.error(
          "‚ùå SIMPLE FORMATTER: OpenRouter error:",
          response.status,
          response.statusText
        )
        return text
      }

      const data = await response.json()
      const formattedText = data.choices?.[0]?.message?.content || text

      console.log("‚úÖ SIMPLE FORMATTER: Success")
      return formattedText.trim()
    } catch (error) {
      console.error("‚ùå SIMPLE FORMATTER: Error:", error)
      return text
    }
  }

  private static async applyLanguageFormatting(
    text: string,
    language: string,
    formatRules: string
  ): Promise<string> {
    if (!text) return text

    console.log("üîß NEW FORMATTER: applyLanguageFormatting called with:", {
      text: text.substring(0, 100),
      language,
      formatRules: formatRules?.substring(0, 50),
    })

    // Check if this is a JSON response with action type
    try {
      const jsonData = JSON.parse(text)
      if (jsonData.action && jsonData.linkUrl) {
        return this.formatActionResponse(jsonData, language)
      }
    } catch (e) {
      // Not JSON, continue with normal formatting
    }

    try {
      const axios = require("axios")
      const openRouterUrl = "https://openrouter.ai/api/v1/chat/completions"
      const openRouterApiKey = process.env.OPENROUTER_API_KEY

      const languageNames = {
        it: "Italian",
        en: "English",
        es: "Spanish",
        pt: "Portuguese",
      }

      const targetLanguage = languageNames[language] || "Italian"

      const languageResponse = await axios.post(
        openRouterUrl,
        {
          model: "openai/gpt-3.5-turbo",
          messages: [
            {
              role: "system",
              content: `You are a WhatsApp message formatter. Your ONLY job is to translate the response to ${targetLanguage} while PRESERVING ALL LISTS AND SPECIFIC INFORMATION.

üö® CRITICAL RULES:
1. Respond ONLY in ${targetLanguage}
2. PRESERVE ALL LISTS - never remove or replace them
3. PRESERVE ALL SPECIFIC INFORMATION - never replace with generic text
4. Only translate the language, don't change the content structure
5. If there are categories or products listed, KEEP THEM EXACTLY

EXAMPLE:
Original: "Ecco le categorie: ‚Ä¢ Cheeses & Dairy ‚Ä¢ Pasta & Rice ‚Ä¢ Sauces"
Good: "Ecco le nostre categorie: ‚Ä¢ Formaggi e Latticini ‚Ä¢ Pasta e Riso ‚Ä¢ Salse"
Bad: "Ciao! Abbiamo tanti prodotti disponibili!" (NEVER replace lists with generic text)

Return ONLY the translated response, no explanations.`,
            },
            {
              role: "user",
              content: text,
            },
          ],
          temperature: 2.0,
          max_tokens: 300,
        },
        {
          headers: {
            Authorization: `Bearer ${openRouterApiKey}`,
            "Content-Type": "application/json",
            "HTTP-Referer": "http://localhost:3001",
            "X-Title": "ShopMe Language Formatter",
          },
          timeout: 10000,
        }
      )

      const formattedText =
        languageResponse.data.choices[0]?.message?.content?.trim() || text
      console.log("üîß NEW FORMATTER: LLM response:", formattedText)
      console.log(`‚úÖ Language formatting to ${targetLanguage} completed`)
      return formattedText
    } catch (error) {
      console.error("‚ùå Language formatting error:", error)
      return text // Return original text if formatting fails
    }
  }

  private static formatActionResponse(jsonData: any, language: string): string {
    const { action, linkUrl, expiresAt } = jsonData

    if (language === "it") {
      switch (action) {
        case "cart":
          return `Ecco il tuo carrello: ${linkUrl}\n\nIl link scadr√† il ${new Date(expiresAt).toLocaleDateString("it-IT")} alle ${new Date(expiresAt).toLocaleTimeString("it-IT", { hour: "2-digit", minute: "2-digit" })}. Buon shopping! üõí`
        case "orders":
          return `Ecco i tuoi ordini: ${linkUrl}\n\nIl link scadr√† il ${new Date(expiresAt).toLocaleDateString("it-IT")} alle ${new Date(expiresAt).toLocaleTimeString("it-IT", { hour: "2-digit", minute: "2-digit" })}.`
        case "checkout":
          return `Procedi con il checkout: ${linkUrl}\n\nIl link scadr√† il ${new Date(expiresAt).toLocaleDateString("it-IT")} alle ${new Date(expiresAt).toLocaleTimeString("it-IT", { hour: "2-digit", minute: "2-digit" })}.`
        default:
          return `Ecco il link richiesto: ${linkUrl}\n\nIl link scadr√† il ${new Date(expiresAt).toLocaleDateString("it-IT")} alle ${new Date(expiresAt).toLocaleTimeString("it-IT", { hour: "2-digit", minute: "2-digit" })}.`
      }
    } else {
      // English
      switch (action) {
        case "cart":
          return `Here's your cart: ${linkUrl}\n\nThe link will expire on ${new Date(expiresAt).toLocaleDateString("en-US")} at ${new Date(expiresAt).toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" })}. Happy shopping! üõí`
        case "orders":
          return `Here are your orders: ${linkUrl}\n\nThe link will expire on ${new Date(expiresAt).toLocaleDateString("en-US")} at ${new Date(expiresAt).toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" })}.`
        case "checkout":
          return `Proceed to checkout: ${linkUrl}\n\nThe link will expire on ${new Date(expiresAt).toLocaleDateString("en-US")} at ${new Date(expiresAt).toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" })}.`
        default:
          return `Here's the requested link: ${linkUrl}\n\nThe link will expire on ${new Date(expiresAt).toLocaleDateString("en-US")} at ${new Date(expiresAt).toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" })}.`
      }
    }
  }

  // Small helper to pull a field value from a product chunk's content
  private static extractFieldFromContent(
    content: string,
    regex: RegExp
  ): string | null {
    if (!content) return null
    try {
      const m = content.match(regex)
      if (m && m[1]) return m[1].trim()
    } catch (e) {
      // ignore
    }
    return null
  }

  private static async applyWhatsAppFormatting(text: string): Promise<string> {
    if (!text) return text

    try {
      const axios = require("axios")
      const openRouterUrl = "https://openrouter.ai/api/v1/chat/completions"
      const openRouterApiKey = process.env.OPENROUTER_API_KEY

      const formattingResponse = await axios.post(
        openRouterUrl,
        {
          model: "openai/gpt-3.5-turbo",
          messages: [
            {
              role: "system",
              content: `You are a WhatsApp message formatter for ShopME, an Italian food e-commerce. Your ONLY job is to make the text natural and conversational for WhatsApp.

üé≠ PERSONALIT√Ä E STILE:
- Tono: Professionale ma caldo e accogliente, tipicamente italiano
- Multilingua: Adatta automaticamente la lingua all'utente
- Proattivo: Suggerisce prodotti correlati e ricette abbinate
- Esperto: Condivide conoscenze sui prodotti italiani e la loro origine

üìã BEST PRACTICES:
1. Sempre contestualizza le risposte con le informazioni dell'utente
2. Suggerisce abbinamenti quando possibile (ricette + prodotti)
3. √à specifico sui dettagli dei prodotti (origine, caratteristiche)
4. Offre alternative se un prodotto non √® disponibile
5. Facilita il contatto con l'operatore quando necessario

üö® CRITICAL RULES - FOLLOW EXACTLY:
1. NEVER use any markdown formatting (no **bold**, _italics_, ~strikethrough~, \`code\`)
2. NEVER use bullet points, dashes, or structured lists
3. Write in flowing, natural sentences
4. Use simple line breaks only when necessary
5. Make it sound like a friendly conversation
6. Do NOT add any NEW links, websites, or URLs that are not in the original text
7. DO include any links that are already present in the original text
8. Do NOT add any additional information not in the original text
9. Do NOT use any formatting symbols or special characters
10. Be proactive and suggest related products or recipes
11. Share knowledge about Italian products and their origins
12. Always contextualize responses with user information
13. Offer alternatives when products are not available

EXAMPLE OF GOOD FORMATTING:
"Ciao! Offriamo spedizione per 5 EUR con consegna entro 3-5 giorni lavorativi, e confezione regalo per 30 EUR con messaggio personalizzato e materiali premium. Ti consiglio anche di abbinare il nostro Parmigiano Reggiano DOP con il nostro Aceto Balsamico di Modena IGP per un sapore autentico italiano!"

EXAMPLE OF BAD FORMATTING (NEVER DO THIS):
"- **Spedizione**: 5 EUR
- **Confezione regalo**: 30 EUR"

non invnetare stai nei dati che ricevi magari condiscei manon invenare.
tono professionale e cordiale perche' parli con un cliente  privilegiatao dell'altra italia
Return ONLY the natural, unformatted text, no explanations.`,
            },
            {
              role: "user",
              content: text,
            },
          ],
          temperature: 0.3, // Zero temperature to prevent inventions
          max_tokens: 4000,
        },
        {
          headers: {
            Authorization: `Bearer ${openRouterApiKey}`,
            "Content-Type": "application/json",
          },
          timeout: 10000,
        }
      )

      if (formattingResponse.data?.choices?.[0]?.message?.content) {
        return formattingResponse.data.choices[0].message.content.trim()
      }
    } catch (error) {
      console.error("‚ùå WhatsApp formatting failed, using original:", error)
    }

    return text
  }
}
