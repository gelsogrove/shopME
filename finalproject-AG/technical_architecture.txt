
## TECHNICAL ARCHITECTURE

### Meta WhatsApp Business API Integration
For the MVP phase, the following approach will be implemented for WhatsApp integration:

- **WhatsApp Business API Playground**: Initial implementation will use Meta's WhatsApp Business API Playground for testing and demonstration
- **Webhook Implementation**: Backend will implement the required webhook endpoints to receive and process WhatsApp messages
- **Message Templates**: Pre-approved message templates will be created for notifications and initial outreach
- **Interactive Messages**: Implementation of buttons, lists, and quick replies for enhanced user experience
- **Media Support**: Support for images, documents, and location sharing
- **Contact Center Integration**: Ability to hand off conversations to human agents when needed

In the production phase, the platform will transition to a full WhatsApp Business API implementation with:

- **Dedicated WhatsApp Business Account**: Official business presence on WhatsApp
- **Green Tick Verification**: Verified business status for enhanced trust
- **Multiple Phone Numbers**: Support for multiple business phone numbers across workspaces
- **Higher Rate Limits**: Increased message volume capabilities
- **Advanced Analytics**: Detailed messaging metrics and performance data
- **Automated Quality Score Management**: System to maintain high quality scores with Meta

### Operator Dashboard Interface
The platform provides a comprehensive operator dashboard with the following capabilities:

- **Chat Management**:
  - View all active and past customer conversations
  - Real-time chat notifications
  - Chat history with full context
  - Message search functionality
  - Visual indicators for new/unread messages
  - Ability to take over conversations from AI

- **Chatbot Controls**:
  - Activate/deactivate the WhatsApp chatbot for the entire workspace
  - Individual customer-level chatbot toggle
  - Test chatbot responses before deploying
  - Monitor chatbot performance metrics
  - View and edit active prompts

- **Customer Management**:
  - Complete customer profile viewing
  - Edit customer information and preferences
  - View customer interaction history
  - Block/unblock problematic customers
  - Customer segmentation for targeted campaigns

- **Product and Offer Management**:
  - Add/edit/remove products from catalog
  - Create and manage product categories
  - Configure time-limited promotional offers
  - Upload and manage product images
  - Set pricing and inventory levels

- **Supplier Management**:
  - Add and manage product suppliers
  - Track supplier information and contacts
  - Associate products with suppliers
  - View supplier-specific product listings

- **Analytics Dashboard**:
  - Overview of key performance metrics
  - Conversation volume trends
  - Customer engagement statistics
  - Product interest analytics
  - AI performance monitoring

- **Multi-Agent Capabilities** (Out of Scope for MVP):
  - Multiple operators working simultaneously on the same workspace
  - Chat assignment and reassignment between agents
  - Agent presence indicators and activity tracking
  - Role-based access controls for different agent types
  - Agent performance analytics and workload distribution

### Frontend
- **Framework**: React with Vite for ultra-fast HMR
- **Styling**: Tailwind CSS with shadcn/ui components
- **Language**: TypeScript for type safety
- **State Management**: React Context API and hooks
- **Testing**: Jest and React Testing Library
- **Build Tool**: Vite
- **Package Manager**: NPM

### Backend
- **Runtime**: Node.js with Express.js
- **Architecture**: Domain Driven Design (DDD) pattern
- **Language**: TypeScript
- **API**: RESTful with OpenAPI specification
- **Authentication**: JWT with HTTP-only cookies
- **Monorepo Structure**: Managed with Turborepo
- **Validation**: Joi for schema validation
- **Testing**: Jest and Supertest

### Architecture Diagram

```mermaid
flowchart TB
    subgraph "User Layer"
        User["Customer via WhatsApp"] 
        Operator["Business Operator"]
    end

    subgraph "External Services"
        WhatsAppAPI["Meta WhatsApp Business API"]
        LLM["OpenRouter LLM Services"]
        PaymentGateway["Payment Processors"]
    end

    subgraph "Frontend Layer"
        ReactApp["Frontend App\n(React + TypeScript + Tailwind)"]
        AdminPanel["Admin Dashboard\n(shadcn/ui Components)"]
        PromptManager["Prompt Management UI"]
    end

    subgraph "API Layer"
        ExpressAPI["Express.js API Server"]
        Middleware["Middleware\n(Auth, Validation, Rate Limiting)"]
        Controllers["Controllers"]
        Routes["API Routes"]
    end

    subgraph "Application Layer"
        Services["Application Services"]
        UseCases["Use Cases"]
        DTOs["Data Transfer Objects"]
    end

    subgraph "Domain Layer"
        Entities["Domain Entities"]
        ValueObjects["Value Objects"]
        Repositories["Repository Interfaces"]
        DomainEvents["Domain Events"]
    end

    subgraph "Infrastructure Layer"
        PrismaORM["Prisma ORM"]
        RepoImpl["Repository Implementations"]
        ExternalServices["External Service Adapters"]
        Messaging["Messaging Infrastructure"]
    end

    subgraph "Database Layer"
        PostgreSQL["PostgreSQL Database"]
        Redis["Redis Cache"]
    end

    %% Connections
    User <--> WhatsAppAPI
    WhatsAppAPI <--> ExpressAPI
    Operator --> ReactApp
    ReactApp --> ExpressAPI
    ExpressAPI <--> Middleware
    Middleware <--> Controllers
    Controllers <--> Routes
    ReactApp --> AdminPanel
    ReactApp --> PromptManager

    Routes --> Services
    Services --> UseCases
    UseCases --> DTOs
    UseCases --> Repositories
    Repositories --> Entities
    Entities --> ValueObjects
    Entities --> DomainEvents
    Repositories --> RepoImpl
    RepoImpl --> PrismaORM
    PrismaORM --> PostgreSQL
    Services --> ExternalServices
    ExternalServices <--> LLM
    ExternalServices <--> PaymentGateway
    ExternalServices --> Messaging
    Redis <--> PrismaORM

    %% Styling
    classDef frontend fill:#42A5F5,stroke:#1976D2,color:white
    classDef backend fill:#66BB6A,stroke:#388E3C,color:white
    classDef database fill:#AB47BC,stroke:#7B1FA2,color:white
    classDef external fill:#FF7043,stroke:#E64A19,color:white
    classDef domain fill:#FFCA28,stroke:#FFB300,color:black
    classDef user fill:#78909C,stroke:#455A64,color:white

    class ReactApp,AdminPanel,PromptManager frontend
    class ExpressAPI,Middleware,Controllers,Routes,Services,UseCases,DTOs backend
    class PostgreSQL,Redis database
    class WhatsAppAPI,LLM,PaymentGateway external
    class Entities,ValueObjects,Repositories,DomainEvents domain
    class User,Operator user
    class PrismaORM,RepoImpl,ExternalServices,Messaging backend
```

#### Architecture Pattern and Rationale

ShopMe uses a Domain-Driven Design (DDD) architecture with clean separation of concerns across multiple layers. This architecture was chosen for several reasons:

**Benefits:**

1. **Business Focus**: Places core business concepts at the center of the application, making it easier to align with stakeholder goals
2. **Scalability**: Clear layer separation allows independent scaling of different components
3. **Maintainability**: Well-defined boundaries between layers make the codebase easier to maintain
4. **Testability**: Each layer can be tested in isolation without dependencies on other layers
5. **Flexibility**: External services can be swapped without affecting the core domain logic
6. **Multi-tenant Design**: Supports clean isolation between different businesses on the platform
7. **Security**: Layered approach helps implement security controls at appropriate levels

**Trade-offs:**

1. **Initial Complexity**: More boilerplate and indirection compared to simpler architectures
2. **Learning Curve**: Team members need to understand DDD concepts
3. **Development Speed**: May slow initial development compared to more rapid approaches
4. **Performance Overhead**: Additional abstraction layers can introduce minor performance costs
5. **Decision Overhead**: Requires more architectural decisions during development

The architecture's strengths in maintainability, scalability, and business alignment outweigh these trade-offs for a complex, multi-tenant application like ShopMe that handles sensitive customer data and complex business processes.

### Database
- **Primary Database**: PostgreSQL
- **ORM**: Prisma for type-safe database access
- **Cache Layer**: Redis for performance optimization
- **Migrations**: Prisma Migration for version control
- **Backup Strategy**: Automated daily backups with point-in-time recovery

### Authentication and Token Management

The application implements a secure JWT (JSON Web Token) based authentication system:

- **Token Structure**:
  - Access tokens with 1-hour expiration
  - Refresh tokens with 7-day expiration
  - Tokens stored in HTTP-only cookies for XSS protection
  - CSRF protection implemented for security

- **Token Flow**:
  - Initial authentication generates both access and refresh tokens
  - Access token used for API authorization
  - Refresh token used to obtain new access tokens without re-authentication
  - Token revocation on logout

- **Security Measures**:
  - Secret keys rotated regularly
  - Token signing with HS256 algorithm
  - Token payload minimization (only essential claims)
  - Validation of token source through HTTP headers
  - Rate limiting on token endpoints

- **Permission Model**:
  - Role-based access control (Admin, Manager, Agent)
  - Resource-level permission checking
  - Workspace-scoped authorization
  - Audit logging of authentication events

- **Secure Link Generation**:
  - One-hour temporary security tokens for sensitive operations
  - Encrypted payload containing operation type, resource ID, and timestamp
  - URL-safe token format for easy sharing via messaging
  - Single-use tokens for critical operations (payments, document access)
  - IP-based validation for additional security layer
  - Automatic invalidation after use or expiration
  - Token verification prior to any sensitive data access

### Domain-Driven Design Architecture

The backend follows a Domain-Driven Design (DDD) architecture as specified in the project's ARCHITECTURE.md:

- **Layer Separation**:
  - **Domain Layer**: Core business entities and rules
  - **Application Layer**: Use cases and application services
  - **Infrastructure Layer**: Technical implementations and external services
  - **Interfaces Layer**: API controllers and routes

- **Key Design Principles**:
  - Business domain at the center of design
  - Clear boundaries between layers
  - Repository pattern for data access
  - Dependency inversion principle

- **Data Flows**:
  - External requests enter through Interfaces layer
  - Controllers delegate to Application services
  - Application services orchestrate Domain entities
  - Infrastructure layer handles persistence and external communications
